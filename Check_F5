#!/usr/bin/env bash
set -euo pipefail

#######################################
# CONFIG
#######################################
DEVICES_FILE="devices.txt"          # 1 host par ligne (IP/FQDN), lignes vides/# ignor√©es
BASE_DIR="./checks"
TS=$(date +%Y%m%d-%H%M%S)

#######################################
# PRECHECKS
#######################################
for bin in ssh sshpass awk sed sort date mkdir wc tr; do
  command -v "$bin" >/dev/null || { echo "‚ùå $bin requis"; exit 1; }
done

[[ -f "$DEVICES_FILE" ]] || { echo "‚ùå Fichier √©quipements introuvable : $DEVICES_FILE"; exit 1; }

#######################################
# INPUTS
#######################################
read -rp "Utilisateur SSH (compte qui arrive en tmsh): " SSH_USER
read -s -rp "Mot de passe SSH: " SSH_PASS
echo

RUN_DIR="${BASE_DIR}/${TS}"
mkdir -p "$RUN_DIR"

echo "üìÅ R√©pertoire run : $RUN_DIR"
echo

#######################################
# REMOTE SCRIPT (printed to stdout)
# Marker ###SUMMARY### splits detail vs summary
#######################################
REMOTE_BASH=$(cat <<'RB'
set -euo pipefail

trim() {
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf "%s" "$s"
}

norm_status() {
  local s="${1:-UNKNOWN}"
  s="$(trim "$s")"
  s="$(printf "%s" "$s" | tr '[:lower:]' '[:upper:]')"

  if [[ "$s" == *"AVAILABLE"* || "$s" == *"UP"* ]]; then
    echo "UP"; return 0
  fi
  if [[ "$s" == *"OFFLINE"* || "$s" == *"DOWN"* || "$s" == *"UNAVAILABLE"* ]]; then
    echo "DOWN"; return 0
  fi
  echo "UNKNOWN"
}

first_availability_from_show() {
  local line val
  while IFS= read -r line; do
    case "$line" in
      *Availability*:* )
        val="${line#*:}"
        val="$(trim "$val")"
        [[ -n "$val" ]] && { printf "%s" "$val"; return 0; }
        ;;
    esac
  done
  printf "UNKNOWN"
}

get_partitions() {
  tmsh -c "list auth partition one-line" \
  | awk '$1=="auth" && $2=="partition" {print $3}' \
  | sed '/^$/d' \
  | sort -u
}

# ---------- ASM / AFM POLICIES ----------
get_asm_policies() {
  tmsh -c "list asm policy recursive" 2>/dev/null \
  | awk '$1=="asm" && $2=="policy" {print $3}' \
  | sed '/^$/d' | sort -u
}

get_afm_fw_policies() {
  tmsh -c "list security firewall policy recursive" 2>/dev/null \
  | awk '$1=="security" && $2=="firewall" && $3=="policy" {print $4}' \
  | sed '/^$/d' | sort -u
}

get_afm_nat_policies() {
  tmsh -c "list security nat policy recursive" 2>/dev/null \
  | awk '$1=="security" && $2=="nat" && $3=="policy" {print $4}' \
  | sed '/^$/d' | sort -u
}

get_afm_protocol_security_policies() {
  tmsh -c "list security protocol-security policy recursive" 2>/dev/null \
  | awk '$1=="security" && $2=="protocol-security" && $3=="policy" {print $4}' \
  | sed '/^$/d' | sort -u
}

# ---------- VS ----------
get_vs_list() {
  local P="$1"
  tmsh -c "cd /${P}; list ltm virtual recursive one-line" 2>/dev/null \
  | awk '$1=="ltm" && $2=="virtual" {print $3}'
}

get_vs_avail() {
  local P="$1" VS="$2"
  tmsh -c "cd /${P}; show ltm virtual ${VS}" 2>/dev/null | first_availability_from_show
}

# ---------- POOLS ----------
get_pool_list() {
  local P="$1"
  tmsh -c "cd /${P}; list ltm pool recursive one-line" 2>/dev/null \
  | awk '$1=="ltm" && $2=="pool" {print $3}'
}

get_pool_avail() {
  local P="$1" POOL="$2"
  tmsh -c "cd /${P}; show ltm pool ${POOL}" 2>/dev/null | first_availability_from_show
}

get_pool_members_status() {
  local P="$1" POOL="$2"
  local line member="" status="" val=""

  shopt -s nocasematch
  local RAW
  RAW="$(tmsh -c "cd /${P}; show ltm pool ${POOL} members" 2>/dev/null || true)"

  while IFS= read -r line; do
    if [[ "$line" == *"LTM::Pool Member:"* ]]; then
      if [[ -n "$member" && -z "$status" ]]; then
        printf "%s ; UNKNOWN\n" "$member"
      fi
      member="${line#*LTM::Pool Member:}"
      member="$(trim "$member")"
      status=""
      continue
    fi

    if [[ -n "$member" ]]; then
      if [[ "$line" == *"Availability"*:* ]]; then
        val="${line#*:}"; val="$(trim "$val")"; status="${val:-UNKNOWN}"
      elif [[ "$line" == *"State"*:* && -z "$status" ]]; then
        val="${line#*:}"; val="$(trim "$val")"; status="${val:-UNKNOWN}"
      elif [[ "$line" == *"Session"*:* && -z "$status" ]]; then
        val="${line#*:}"; val="$(trim "$val")"; status="${val:-UNKNOWN}"
      fi

      if [[ -n "$status" ]]; then
        printf "%s ; %s\n" "$member" "$status"
        member=""; status=""
      fi
    fi
  done <<< "$RAW"

  if [[ -n "$member" && -z "$status" ]]; then
    printf "%s ; UNKNOWN\n" "$member"
  fi

  shopt -u nocasematch
}

# ---------- NODES ----------
get_node_list() {
  local P="$1"
  local out=""

  out="$(tmsh -c "cd /${P}; list ltm node recursive one-line" 2>/dev/null \
        | awk '$1=="ltm" && $2=="node" {print $3}' || true)"

  if [[ -z "${out:-}" ]]; then
    out="$(tmsh -c "cd /${P}; list ltm node one-line" 2>/dev/null \
          | awk '$1=="ltm" && $2=="node" {print $3}' || true)"
  fi

  if [[ -z "${out:-}" ]]; then
    out="$(tmsh -c "cd /${P}; list ltm node recursive" 2>/dev/null \
          | awk '$1=="ltm" && $2=="node" {print $3}' || true)"
  fi

  printf "%s\n" "$out" | sed '/^$/d' | sort -u
}

get_node_ip() {
  local P="$1" NODE="$2"
  tmsh -c "cd /${P}; list ltm node ${NODE} one-line" 2>/dev/null \
  | awk '{ for (i=1;i<=NF;i++) if ($i=="address") { print $(i+1); exit } }' \
  | sed 's/[;}]//g' || true
}

get_node_avail() {
  local P="$1" NODE="$2"
  tmsh -c "cd /${P}; show ltm node ${NODE}" 2>/dev/null | first_availability_from_show
}

#######################################
# Counters
#######################################
VS_TOTAL=0; VS_UP=0; VS_DOWN=0; VS_UNK=0
POOL_TOTAL=0; POOL_UP=0; POOL_DOWN=0; POOL_UNK=0
MEM_TOTAL=0; MEM_UP=0; MEM_DOWN=0; MEM_UNK=0
NODE_TOTAL=0; NODE_UP=0; NODE_DOWN=0; NODE_UNK=0

#######################################
# Policies counts + lists
#######################################
ASM_LIST="$(get_asm_policies || true)"
ASM_COUNT=$(printf "%s\n" "$ASM_LIST" | sed '/^$/d' | wc -l | awk '{print $1}')

AFM_FW="$(get_afm_fw_policies || true)"
AFM_NAT="$(get_afm_nat_policies || true)"
AFM_PS="$(get_afm_protocol_security_policies || true)"

AFM_FW_COUNT=$(printf "%s\n" "$AFM_FW" | sed '/^$/d' | wc -l | awk '{print $1}')
AFM_NAT_COUNT=$(printf "%s\n" "$AFM_NAT" | sed '/^$/d' | wc -l | awk '{print $1}')
AFM_PS_COUNT=$(printf "%s\n" "$AFM_PS" | sed '/^$/d' | wc -l | awk '{print $1}')
AFM_TOTAL_COUNT=$((AFM_FW_COUNT + AFM_NAT_COUNT + AFM_PS_COUNT))

#######################################
# DETAIL OUTPUT
#######################################
echo "########################################"
echo "BIG-IP CHECK (LTM + ASM + AFM)"
echo "Date : $(date)"
echo "########################################"
echo

echo "===== ASM POLICIES ====="
[[ -n "${ASM_LIST:-}" ]] && printf "%s\n" "$ASM_LIST" || echo "(0 ASM policies)"
echo

echo "===== AFM POLICIES ====="
echo "-- Firewall"
[[ -n "${AFM_FW:-}" ]] && printf "%s\n" "$AFM_FW" || echo "(0 firewall policies)"
echo
echo "-- NAT"
[[ -n "${AFM_NAT:-}" ]] && printf "%s\n" "$AFM_NAT" || echo "(0 nat policies)"
echo
echo "-- Protocol Security"
[[ -n "${AFM_PS:-}" ]] && printf "%s\n" "$AFM_PS" || echo "(0 protocol-security policies)"
echo

PARTS="$(get_partitions || true)"
[[ -n "${PARTS:-}" ]] || { echo "‚ùå Aucune partition visible"; exit 1; }

while IFS= read -r P || [[ -n "$P" ]]; do
  [[ -z "$P" ]] && continue

  echo "======================================"
  echo "PARTITION: /$P"
  echo "======================================"

  # VS
  echo
  echo "[VS]"
  VS_LIST="$(get_vs_list "$P" || true)"
  if [[ -z "${VS_LIST:-}" ]]; then
    echo "(0 VS)"
  else
    while IFS= read -r VS || [[ -n "$VS" ]]; do
      [[ -z "$VS" ]] && continue
      AV="$(get_vs_avail "$P" "$VS")"
      ST="$(norm_status "$AV")"

      VS_TOTAL=$((VS_TOTAL+1))
      case "$ST" in
        UP) VS_UP=$((VS_UP+1)) ;;
        DOWN) VS_DOWN=$((VS_DOWN+1)) ;;
        *) VS_UNK=$((VS_UNK+1)) ;;
      esac

      printf "%s ; %s\n" "$VS" "$AV"
    done <<< "$VS_LIST"
  fi

  # POOLS + MEMBERS
  echo
  echo "[POOLS]"
  POOL_LIST="$(get_pool_list "$P" || true)"
  if [[ -z "${POOL_LIST:-}" ]]; then
    echo "(0 POOLS)"
  else
    while IFS= read -r POOL || [[ -n "$POOL" ]]; do
      [[ -z "$POOL" ]] && continue
      PAV="$(get_pool_avail "$P" "$POOL")"
      PST="$(norm_status "$PAV")"

      POOL_TOTAL=$((POOL_TOTAL+1))
      case "$PST" in
        UP) POOL_UP=$((POOL_UP+1)) ;;
        DOWN) POOL_DOWN=$((POOL_DOWN+1)) ;;
        *) POOL_UNK=$((POOL_UNK+1)) ;;
      esac

      printf "%s ; %s\n" "$POOL" "$PAV"

      MEMBERS="$(get_pool_members_status "$P" "$POOL" || true)"
      if [[ -z "${MEMBERS:-}" ]]; then
        echo "  (0 members ou statut non lisible)"
      else
        while IFS= read -r m || [[ -n "$m" ]]; do
          [[ -z "$m" ]] && continue
          printf "  %s\n" "$m"

          ms="${m#*;}"
          ms="$(trim "$ms")"
          mst="$(norm_status "$ms")"
          MEM_TOTAL=$((MEM_TOTAL+1))
          case "$mst" in
            UP) MEM_UP=$((MEM_UP+1)) ;;
            DOWN) MEM_DOWN=$((MEM_DOWN+1)) ;;
            *) MEM_UNK=$((MEM_UNK+1)) ;;
          esac
        done <<< "$MEMBERS"
      fi
    done <<< "$POOL_LIST"
  fi

  # NODES
  echo
  echo "[NODES]"
  NODE_LIST="$(get_node_list "$P" || true)"
  if [[ -z "${NODE_LIST:-}" ]]; then
    echo "(0 NODES)"
  else
    while IFS= read -r NODE || [[ -n "$NODE" ]]; do
      [[ -z "$NODE" ]] && continue
      IP="$(get_node_ip "$P" "$NODE")"
      [[ -n "${IP:-}" ]] || IP="UNKNOWN"
      NAV="$(get_node_avail "$P" "$NODE")"
      NST="$(norm_status "$NAV")"

      NODE_TOTAL=$((NODE_TOTAL+1))
      case "$NST" in
        UP) NODE_UP=$((NODE_UP+1)) ;;
        DOWN) NODE_DOWN=$((NODE_DOWN+1)) ;;
        *) NODE_UNK=$((NODE_UNK+1)) ;;
      esac

      printf "%s ; %s ; %s\n" "$NODE" "$IP" "$NAV"
    done <<< "$NODE_LIST"
  fi

  echo
done <<< "$PARTS"

#######################################
# SUMMARY OUTPUT (marker)
#######################################
echo "###SUMMARY###"
echo "Run date: $(date)"
echo
echo "[POLICIES]"
echo "ASM policies total: ${ASM_COUNT}"
echo "AFM firewall policies total: ${AFM_FW_COUNT}"
echo "AFM nat policies total: ${AFM_NAT_COUNT}"
echo "AFM protocol-security policies total: ${AFM_PS_COUNT}"
echo "AFM policies total: ${AFM_TOTAL_COUNT}"
echo
echo "[LTM]"
echo "VS total: ${VS_TOTAL} | UP: ${VS_UP} | DOWN: ${VS_DOWN} | UNKNOWN: ${VS_UNK}"
echo "Pools total: ${POOL_TOTAL} | UP: ${POOL_UP} | DOWN: ${POOL_DOWN} | UNKNOWN: ${POOL_UNK}"
echo "Pool members total: ${MEM_TOTAL} | UP: ${MEM_UP} | DOWN: ${MEM_DOWN} | UNKNOWN: ${MEM_UNK}"
echo "Nodes total: ${NODE_TOTAL} | UP: ${NODE_UP} | DOWN: ${NODE_DOWN} | UNKNOWN: ${NODE_UNK}"
RB
)

#######################################
# MAIN LOOP (multi devices)
#######################################
TOTAL=$(grep -Ev '^\s*#|^\s*$' "$DEVICES_FILE" | wc -l | awk '{print $1}')
COUNT=0
FAIL=0

echo "üìã Multi-√©quipements"
echo "üìÑ Devices file : $DEVICES_FILE"
echo "üî¢ Total        : $TOTAL"
echo "üìÖ Run TS       : $TS"
echo

while IFS= read -r LINE || [[ -n "$LINE" ]]; do
  HOST=$(printf "%s" "$LINE" | tr -d '\r' | xargs)
  [[ -z "$HOST" || "$HOST" =~ ^# ]] && continue

  COUNT=$((COUNT+1))
  HOST_DIR="${RUN_DIR}/${HOST}"
  mkdir -p "$HOST_DIR"

  DETAIL_FILE="${HOST_DIR}/check_LTM_ASM_AFM.txt"
  SUMMARY_FILE="${HOST_DIR}/summary_LTM_ASM_AFM.txt"

  echo "======================================"
  echo "‚û°Ô∏è  [$COUNT/$TOTAL] BIG-IP : $HOST"
  echo "   D√©tail  : $DETAIL_FILE"
  echo "   Synth√®se: $SUMMARY_FILE"
  echo "======================================"

  # Ex√©cute une seule fois c√¥t√© remote, puis split en 2 fichiers localement
  if sshpass -p "$SSH_PASS" ssh -T \
      -o StrictHostKeyChecking=no \
      -o ConnectTimeout=15 \
      -o LogLevel=Error \
      "${SSH_USER}@${HOST}" "run util bash -s" \
      <<< "$REMOTE_BASH" \
      | awk -v OUT="$DETAIL_FILE" -v SUM="$SUMMARY_FILE" '
          BEGIN{mode=0}
          $0=="###SUMMARY###"{mode=1; next}
          mode==0{print >> OUT; next}
          mode==1{print >> SUM; next}
        '; then
    echo "‚úÖ Termin√© : $HOST"
  else
    echo "‚ùå √âchec : $HOST"
    FAIL=$((FAIL+1))
  fi

  echo
done < "$DEVICES_FILE"

echo "======================================"
echo "üèÅ Termin√©"
echo "üìÅ Run dir : $RUN_DIR"
echo "‚ùå √âchecs  : $FAIL"
echo "======================================"

(( FAIL == 0 )) || exit 1
