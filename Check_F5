#!/usr/bin/env bash
set -euo pipefail

#######################################
# CONFIG
#######################################
BASE_DIR="./checks"
TS=$(date +%Y%m%d-%H%M%S)

for bin in ssh sshpass awk sed sort date mkdir; do
  command -v "$bin" >/dev/null || { echo "‚ùå $bin requis"; exit 1; }
done

read -rp "Nom/IP de l'√©quipement BIG-IP: " HOST
read -rp "Utilisateur SSH (compte qui arrive en tmsh): " SSH_USER
read -s -rp "Mot de passe SSH: " SSH_PASS
echo

HOST_DIR="${BASE_DIR}/${TS}/${HOST}"
mkdir -p "$HOST_DIR"
OUTPUT_FILE="${HOST_DIR}/check_LTM_ASM_AFM.txt"

echo "üìÅ R√©sultat stock√© dans : $OUTPUT_FILE"
echo

sshpass -p "$SSH_PASS" ssh -T \
  -o StrictHostKeyChecking=no \
  -o ConnectTimeout=15 \
  -o LogLevel=Error \
  "${SSH_USER}@${HOST}" "run util bash -s" > "$OUTPUT_FILE" <<'REMOTE_BASH'
set -euo pipefail

trim() {
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf "%s" "$s"
}

# lit stdin d'un "show ..." et retourne la 1√®re valeur Availability
first_availability_from_show() {
  local line val
  while IFS= read -r line; do
    case "$line" in
      *Availability*:* )
        val="${line#*:}"
        val="$(trim "$val")"
        [[ -n "$val" ]] && { printf "%s" "$val"; return 0; }
        ;;
    esac
  done
  printf "UNKNOWN"
}

get_partitions() {
  tmsh -c "list auth partition one-line" \
  | awk '$1=="auth" && $2=="partition" {print $3}' \
  | sed '/^$/d' \
  | sort -u
}

# ---------- VS ----------
get_vs_list() {
  local P="$1"
  tmsh -c "cd /${P}; list ltm virtual recursive one-line" 2>/dev/null \
  | awk '$1=="ltm" && $2=="virtual" {print $3}'
}

get_vs_avail() {
  local P="$1" VS="$2"
  tmsh -c "cd /${P}; show ltm virtual ${VS}" 2>/dev/null | first_availability_from_show
}

# ---------- POOLS ----------
get_pool_list() {
  local P="$1"
  tmsh -c "cd /${P}; list ltm pool recursive one-line" 2>/dev/null \
  | awk '$1=="ltm" && $2=="pool" {print $3}'
}

get_pool_avail() {
  local P="$1" POOL="$2"
  tmsh -c "cd /${P}; show ltm pool ${POOL}" 2>/dev/null | first_availability_from_show
}

get_pool_members_status() {
  local P="$1" POOL="$2"
  local line member="" status="" val=""

  shopt -s nocasematch
  local RAW
  RAW="$(tmsh -c "cd /${P}; show ltm pool ${POOL} members" 2>/dev/null || true)"

  while IFS= read -r line; do
    if [[ "$line" == *"LTM::Pool Member:"* ]]; then
      if [[ -n "$member" && -z "$status" ]]; then
        printf "%s ; UNKNOWN\n" "$member"
      fi
      member="${line#*LTM::Pool Member:}"
      member="$(trim "$member")"
      status=""
      continue
    fi

    if [[ -n "$member" ]]; then
      if [[ "$line" == *"Availability"*:* ]]; then
        val="${line#*:}"; val="$(trim "$val")"; status="${val:-UNKNOWN}"
      elif [[ "$line" == *"State"*:* && -z "$status" ]]; then
        val="${line#*:}"; val="$(trim "$val")"; status="${val:-UNKNOWN}"
      elif [[ "$line" == *"Session"*:* && -z "$status" ]]; then
        val="${line#*:}"; val="$(trim "$val")"; status="${val:-UNKNOWN}"
      fi

      if [[ -n "$status" ]]; then
        printf "%s ; %s\n" "$member" "$status"
        member=""; status=""
      fi
    fi
  done <<< "$RAW"

  if [[ -n "$member" && -z "$status" ]]; then
    printf "%s ; UNKNOWN\n" "$member"
  fi

  shopt -u nocasematch
}

# ---------- NODES ----------
get_node_list() {
  local P="$1"
  local out=""

  out="$(tmsh -c "cd /${P}; list ltm node recursive one-line" 2>/dev/null \
        | awk '$1=="ltm" && $2=="node" {print $3}' || true)"

  if [[ -z "${out:-}" ]]; then
    out="$(tmsh -c "cd /${P}; list ltm node one-line" 2>/dev/null \
          | awk '$1=="ltm" && $2=="node" {print $3}' || true)"
  fi

  if [[ -z "${out:-}" ]]; then
    out="$(tmsh -c "cd /${P}; list ltm node recursive" 2>/dev/null \
          | awk '$1=="ltm" && $2=="node" {print $3}' || true)"
  fi

  printf "%s\n" "$out" | sed '/^$/d' | sort -u
}

get_node_ip() {
  local P="$1" NODE="$2"
  # Exemple: ltm node node1 { address 10.0.0.1 ... }
  tmsh -c "cd /${P}; list ltm node ${NODE} one-line" 2>/dev/null \
  | awk '
      {
        for (i=1;i<=NF;i++) {
          if ($i=="address") { print $(i+1); exit }
        }
      }' \
  | sed 's/[;}]//g' \
  || true
}

get_node_avail() {
  local P="$1" NODE="$2"
  tmsh -c "cd /${P}; show ltm node ${NODE}" 2>/dev/null | first_availability_from_show
}

# ---------- ASM / AFM POLICIES ----------
get_asm_policies() {
  tmsh -c "list asm policy recursive" 2>/dev/null \
  | awk '$1=="asm" && $2=="policy" {print $3}' \
  | sed '/^$/d' | sort -u
}

get_afm_fw_policies() {
  tmsh -c "list security firewall policy recursive" 2>/dev/null \
  | awk '$1=="security" && $2=="firewall" && $3=="policy" {print $4}' \
  | sed '/^$/d' | sort -u
}

get_afm_nat_policies() {
  tmsh -c "list security nat policy recursive" 2>/dev/null \
  | awk '$1=="security" && $2=="nat" && $3=="policy" {print $4}' \
  | sed '/^$/d' | sort -u
}

get_afm_protocol_security_policies() {
  tmsh -c "list security protocol-security policy recursive" 2>/dev/null \
  | awk '$1=="security" && $2=="protocol-security" && $3=="policy" {print $4}' \
  | sed '/^$/d' | sort -u
}

#######################################
# OUTPUT
#######################################
echo "########################################"
echo "BIG-IP CHECK (LTM + ASM + AFM)"
echo "Date : $(date)"
echo "########################################"
echo

echo "===== ASM POLICIES ====="
ASM_LIST="$(get_asm_policies || true)"
[[ -n "${ASM_LIST:-}" ]] && printf "%s\n" "$ASM_LIST" || echo "(0 ASM policies)"
echo

echo "===== AFM POLICIES ====="
echo "-- Firewall"
FW_LIST="$(get_afm_fw_policies || true)"
[[ -n "${FW_LIST:-}" ]] && printf "%s\n" "$FW_LIST" || echo "(0 firewall policies)"
echo
echo "-- NAT"
NAT_LIST="$(get_afm_nat_policies || true)"
[[ -n "${NAT_LIST:-}" ]] && printf "%s\n" "$NAT_LIST" || echo "(0 nat policies)"
echo
echo "-- Protocol Security"
PS_LIST="$(get_afm_protocol_security_policies || true)"
[[ -n "${PS_LIST:-}" ]] && printf "%s\n" "$PS_LIST" || echo "(0 protocol-security policies)"
echo

PARTS="$(get_partitions || true)"
[[ -n "${PARTS:-}" ]] || { echo "‚ùå Aucune partition visible"; exit 1; }

while IFS= read -r P || [[ -n "$P" ]]; do
  [[ -z "$P" ]] && continue

  echo "======================================"
  echo "PARTITION: /$P"
  echo "======================================"

  # VS
  echo
  echo "[VS]"
  VS_LIST="$(get_vs_list "$P" || true)"
  if [[ -z "${VS_LIST:-}" ]]; then
    echo "(0 VS)"
  else
    while IFS= read -r VS || [[ -n "$VS" ]]; do
      [[ -z "$VS" ]] && continue
      AV="$(get_vs_avail "$P" "$VS")"
      printf "%s ; %s\n" "$VS" "$AV"
    done <<< "$VS_LIST"
  fi

  # POOLS + MEMBERS
  echo
  echo "[POOLS]"
  POOL_LIST="$(get_pool_list "$P" || true)"
  if [[ -z "${POOL_LIST:-}" ]]; then
    echo "(0 POOLS)"
  else
    while IFS= read -r POOL || [[ -n "$POOL" ]]; do
      [[ -z "$POOL" ]] && continue
      PAV="$(get_pool_avail "$P" "$POOL")"
      printf "%s ; %s\n" "$POOL" "$PAV"

      MEMBERS="$(get_pool_members_status "$P" "$POOL" || true)"
      if [[ -z "${MEMBERS:-}" ]]; then
        echo "  (0 members ou statut non lisible)"
      else
        while IFS= read -r m || [[ -n "$m" ]]; do
          [[ -z "$m" ]] && continue
          printf "  %s\n" "$m"
        done <<< "$MEMBERS"
      fi
    done <<< "$POOL_LIST"
  fi

  # NODES (name ; ip ; status)
  echo
  echo "[NODES]"
  NODE_LIST="$(get_node_list "$P" || true)"
  if [[ -z "${NODE_LIST:-}" ]]; then
    echo "(0 NODES)"
  else
    while IFS= read -r NODE || [[ -n "$NODE" ]]; do
      [[ -z "$NODE" ]] && continue
      IP="$(get_node_ip "$P" "$NODE")"
      [[ -n "${IP:-}" ]] || IP="UNKNOWN"
      NAV="$(get_node_avail "$P" "$NODE")"
      printf "%s ; %s ; %s\n" "$NODE" "$IP" "$NAV"
    done <<< "$NODE_LIST"
  fi

  echo
done <<< "$PARTS"
REMOTE_BASH

echo "‚úÖ Check termin√©"
echo "üìÑ Fichier g√©n√©r√© : $OUTPUT_FILE"
